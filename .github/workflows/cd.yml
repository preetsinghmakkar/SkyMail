name: CD - Deploy to EC2

# Trigger only on push to main branch or manual trigger
on:
  push:
    branches:
      - main
  workflow_dispatch: # Allows manual trigger from GitHub UI

# Environment variables
env:
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  DOCKERHUB_REPOSITORY: ${{ secrets.DOCKERHUB_REPOSITORY }}
  IMAGE_TAG: ${{ github.sha }}

jobs:
  deploy:
    name: Build and Deploy to EC2
    runs-on: ubuntu-latest

    steps:
      # Step 1: Checkout the repository code
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      # Step 2: Set up Docker Buildx
      - name: ÔøΩ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Step 3: Login to Docker Hub
      - name: üîë Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # Step 3.5: Debug - Verify secrets are set and prepare tags
      - name: üîç Prepare Docker Tags
        id: docker_tags
        run: |
          echo "Checking Docker Hub secrets..."
          echo "DOCKERHUB_USERNAME length: ${#DOCKERHUB_USERNAME}"
          echo "DOCKERHUB_REPOSITORY length: ${#DOCKERHUB_REPOSITORY}"
          echo "DOCKERHUB_USERNAME (first 3 chars): ${DOCKERHUB_USERNAME:0:3}***"
          echo "DOCKERHUB_REPOSITORY (first 3 chars): ${DOCKERHUB_REPOSITORY:0:3}***"

          # Build the image name
          IMAGE_NAME="${DOCKERHUB_USERNAME}/${DOCKERHUB_REPOSITORY}"
          echo "Image name: $IMAGE_NAME"

          # Create tags - MUST be newline separated for docker/build-push-action
          TAGS="${IMAGE_NAME}:${{ github.sha }}"$'\n'"${IMAGE_NAME}:latest"

          echo "Tags to be created:"
          echo "$TAGS"

          # Export for next step - use EOF for multi-line
          echo "tags<<EOF" >> $GITHUB_OUTPUT
          echo "$TAGS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "cache_ref=${IMAGE_NAME}:latest" >> $GITHUB_OUTPUT
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_REPOSITORY: ${{ secrets.DOCKERHUB_REPOSITORY }}

      # Step 4: Build and push Docker image to Docker Hub
      - name: üêã Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.docker_tags.outputs.tags }}
          cache-from: type=registry,ref=${{ steps.docker_tags.outputs.cache_ref }}
          cache-to: type=inline

      # Step 5: Deploy to EC2
      - name: üöÄ Deploy to EC2
        run: |
          echo "Preparing SSH connection..."

          # Create SSH key file from secret
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > private_key.pem
          chmod 600 private_key.pem

          echo "Connecting to EC2 and deploying..."

          # SSH into EC2 and execute deployment commands
          ssh -o StrictHostKeyChecking=no \
              -i private_key.pem \
              ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} << 'ENDSSH'
            set -e  # Exit on any error
            
            echo "============================================"
            echo "üöÄ Starting deployment process..."
            echo "============================================"

            # Navigate to application directory
            echo "üìÇ Navigating to application directory..."
            cd /home/${{ secrets.EC2_USERNAME }}/SkyMail || {
              echo "‚ùå ERROR: SkyMail directory not found at /home/${{ secrets.EC2_USERNAME }}/SkyMail"
              exit 1
            }
           
            # Login to Docker Hub from EC2
            echo "üîë Logging into Docker Hub..."
            echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login --username ${{ secrets.DOCKERHUB_USERNAME }} --password-stdin || {
              echo "‚ùå ERROR: Failed to login to Docker Hub"
              exit 1
            }
            
            # Pull latest image
            echo "üì• Pulling latest Docker image..."
            docker pull ${{ secrets.DOCKERHUB_USERNAME }}/${{ secrets.DOCKERHUB_REPOSITORY }}:latest || {
              echo "‚ùå ERROR: Failed to pull Docker image"
              exit 1
            }
            
            # Export image variable for docker-compose
            export DOCKER_IMAGE="${{ secrets.DOCKERHUB_USERNAME }}/${{ secrets.DOCKERHUB_REPOSITORY }}:latest"
            echo "Using image: $DOCKER_IMAGE"
            
            # Pull any updates to services
            echo "üì¶ Pulling service updates..."
            docker compose -f docker-compose.prod.yml pull || true
            
            # Restart backend service with zero-downtime
            echo "üîÑ Restarting backend service..."
            docker compose -f docker-compose.prod.yml up -d --no-deps backend || {
              echo "‚ùå ERROR: Failed to restart backend"
              docker compose -f docker-compose.prod.yml logs --tail=100 backend
              exit 1
            }
            
            # Wait for backend to be healthy
            echo "‚è≥ Waiting for backend health check..."
            HEALTH_CHECK_ATTEMPTS=0
            MAX_ATTEMPTS=30
            
            while [ $HEALTH_CHECK_ATTEMPTS -lt $MAX_ATTEMPTS ]; do
              if docker compose -f docker-compose.prod.yml exec -T backend curl -f http://localhost:8000/health 2>/dev/null; then
                echo "‚úÖ Backend is healthy!"
                break
              fi
              
              HEALTH_CHECK_ATTEMPTS=$((HEALTH_CHECK_ATTEMPTS + 1))
              echo "Attempt $HEALTH_CHECK_ATTEMPTS/$MAX_ATTEMPTS - Backend not ready yet..."
              sleep 2
              
              if [ $HEALTH_CHECK_ATTEMPTS -eq $MAX_ATTEMPTS ]; then
                echo "‚ùå ERROR: Backend health check failed after $MAX_ATTEMPTS attempts"
                echo "Recent logs:"
                docker compose -f docker-compose.prod.yml logs --tail=50 backend
                exit 1
              fi
            done
            
            # Run database migrations (if any)
            echo "üóÑÔ∏è  Running database migrations..."
            docker compose -f docker-compose.prod.yml exec -T backend alembic upgrade head || {
              echo "‚ö†Ô∏è  WARNING: Migrations failed or no migrations to run"
            }
            
            # Restart Celery workers gracefully
            echo "üîÑ Restarting Celery workers..."
            docker compose -f docker-compose.prod.yml restart celery-worker-campaigns || {
              echo "‚ö†Ô∏è  WARNING: Failed to restart celery-worker-campaigns, but continuing..."
            }
            docker compose -f docker-compose.prod.yml restart celery-worker-email-batches || {
              echo "‚ö†Ô∏è  WARNING: Failed to restart celery-worker-email-batches, but continuing..."
            }
            
            # Cleanup old Docker images (older than 72 hours)
            echo "üßπ Cleaning up old Docker images..."
            docker image prune -af --filter "until=72h" || true
            
            # Show current running containers
            echo ""
            echo "============================================"
            echo "‚úÖ Deployment completed successfully!"
            echo "============================================"
            echo ""
            echo "üìä Running containers:"
            docker compose -f docker-compose.prod.yml ps
            echo ""
            echo "============================================"
          ENDSSH

          # Cleanup SSH key
          rm -f private_key.pem

          echo "‚úÖ Deployment script completed"

      # Step 7: Verify deployment
      - name: ‚úÖ Verify Deployment
        run: |
          echo "Verifying deployment..."

          # Recreate SSH key for verification
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > private_key.pem
          chmod 600 private_key.pem

          # Wait a moment for services to stabilize
          sleep 10

          # Test if backend is responding
          ssh -o StrictHostKeyChecking=no \
              -i private_key.pem \
              ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} \
              "curl -f http://localhost:8000/health" || {
            echo "‚ùå ERROR: Backend health check failed"
            rm -f private_key.pem
            exit 1
          }

          # Cleanup
          rm -f private_key.pem

          echo "‚úÖ Deployment verified successfully!"

      # Step 8: Notify on failure (you can extend this with Slack/Discord)
      - name: üì¢ Notify on Failure
        if: failure()
        run: |
          echo "=================================="
          echo "‚ùå DEPLOYMENT FAILED"
          echo "=================================="
          echo "Commit: ${{ github.sha }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Author: ${{ github.actor }}"
          echo "Logs: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          echo "=================================="
          # Add Slack/Discord webhook here if needed

      # Step 9: Cleanup
      - name: üßπ Final Cleanup
        if: always()
        run: |
          rm -f private_key.pem || true
          docker system prune -f || true

      # Step 10: Success summary
      - name: üéâ Deployment Summary
        if: success()
        run: |
          echo "=================================="
          echo "‚úÖ DEPLOYMENT SUCCESSFUL"
          echo "=================================="
          echo "Commit: ${{ github.sha }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Author: ${{ github.actor }}"
          echo "Image: ${{ secrets.DOCKERHUB_USERNAME }}/${{ secrets.DOCKERHUB_REPOSITORY }}:latest"
          echo "=================================="
          echo "üöÄ Your application is now live!"
          echo "=================================="
